name: Pure Go Android (Storage ROM)

on:
  workflow_dispatch:
  push:
    branches: [ "main", "master" ]

permissions:
  contents: write

jobs:
  build-native:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 1. LIMPEZA TOTAL
      - name: Clean Everything
        run: |
          rm -rf android mobile cmd internal build .github/workflows/release.yml || true
          mkdir -p cmd/mobile/assets

      # 2. MANIFESTO COM PERMISSÃO DE ARQUIVO
      - name: Create AndroidManifest.xml
        run: |
          cat << 'EOF' > cmd/mobile/AndroidManifest.xml
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android"
              package="com.kaishuu0123.chibisnes"
              android:versionCode="1"
              android:versionName="1.0">

              <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
              <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
              <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" />

              <application
                  android:label="ChibiSNES"
                  android:debuggable="true"
                  android:requestLegacyExternalStorage="true">
                  
                  <activity android:name="org.golang.app.GoNativeActivity"
                      android:label="ChibiSNES"
                      android:configChanges="orientation|keyboardHidden|screenSize"
                      android:exported="true">
                      <meta-data android:name="android.app.lib_name" android:value="chibisnes" />
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>
              </application>
          </manifest>
          EOF

      # 3. CÓDIGO GO NATIVO (COM LEITURA DE ARQUIVO)
      - name: Create cmd/mobile/main.go
        run: |
          cat << 'EOF' > cmd/mobile/main.go
          package main

          import (
            "encoding/binary"
            "log"
            "math"
            "sync"
            "os"
            "io" 

            "golang.org/x/mobile/app"
            "golang.org/x/mobile/event/lifecycle"
            "golang.org/x/mobile/event/paint"
            "golang.org/x/mobile/event/size"
            "golang.org/x/mobile/event/touch"
            "golang.org/x/mobile/gl"
            "golang.org/x/mobile/asset"

            "github.com/kaishuu0123/chibisnes/chibisnes"
          )

          var (
            console   *chibisnes.Console
            program   gl.Program
            position  gl.Attrib
            texCoord  gl.Attrib
            texture   gl.Texture
            buf       gl.Buffer
            screenW   int
            screenH   int
            mu        sync.Mutex
            pixels    []byte
          )

          const (
            snesW = 512
            snesH = 478
          )

          func main() {
            app.Main(func(a app.App) {
              for e := range a.Events() {
                switch e := a.Filter(e).(type) {
                case lifecycle.Event:
                  if e.Crosses(lifecycle.StageVisible) == lifecycle.CrossOn {
                    startEmulator()
                    onStart()
                  }
                  if e.Crosses(lifecycle.StageVisible) == lifecycle.CrossOff {
                    onStop()
                  }
                case size.Event:
                  screenW = e.WidthPx
                  screenH = e.HeightPx
                case paint.Event:
                  onPaint(a)
                case touch.Event:
                  onTouch(e)
                }
              }
            })
          }

          func startEmulator() {
            mu.Lock()
            defer mu.Unlock()
            
            if console != nil { return }

            // 1. Tenta carregar do Armazenamento
            romData, err := loadRomFromStorage()
            
            // 2. Se falhar, tenta dos Assets (interno)
            if err != nil {
                log.Println("ROM Storage falhou, tentando assets:", err)
                romData, err = loadRomFromAssets()
            }

            if err != nil || len(romData) == 0 {
                log.Println("Nenhuma ROM carregada.")
                // Inicializa console vazio para nao crashar o loop grafico
                console = chibisnes.NewConsole()
                pixels = make([]byte, snesW*snesH*4)
                return
            }

            console = chibisnes.NewConsole()
            console.LoadROM("game.sfc", romData, len(romData))
            
            pixels = make([]byte, snesW*snesH*4)
          }

          func loadRomFromStorage() ([]byte, error) {
             paths := []string{
                 "/sdcard/Download/game.sfc",
                 "/storage/emulated/0/Download/game.sfc",
                 "/sdcard/game.sfc",
             }
             for _, p := range paths {
                 // CORREÇÃO: Usando os.ReadFile que é padrão
                 data, err := os.ReadFile(p)
                 if err == nil && len(data) > 0 {
                     return data, nil
                 }
             }
             return nil, os.ErrNotExist
          }

          func loadRomFromAssets() ([]byte, error) {
             f, err := asset.Open("game.sfc")
             if err != nil { return nil, err }
             defer f.Close()
             
             // CORREÇÃO: asset.File não tem Stat(). Usar io.ReadAll.
             return io.ReadAll(f)
          }

          func onStart() {
            var err error
            program, err = gl.CreateProgram()
            if err != nil { 
                log.Println("GL CreateProgram Error:", err)
                return 
            }

            vs, _ := gl.CreateShader(gl.VERTEX_SHADER)
            gl.ShaderSource(vs, vertexShader)
            gl.CompileShader(vs)
            gl.AttachShader(program, vs)

            fs, _ := gl.CreateShader(gl.FRAGMENT_SHADER)
            gl.ShaderSource(fs, fragmentShader)
            gl.CompileShader(fs)
            gl.AttachShader(program, fs)

            gl.LinkProgram(program)
            gl.UseProgram(program)

            position = gl.GetAttribLocation(program, "position")
            texCoord = gl.GetAttribLocation(program, "texCoord")
            
            gl.Uniform1i(gl.GetUniformLocation(program, "texture"), 0)

            texture = gl.CreateTexture()
            gl.BindTexture(gl.TEXTURE_2D, texture)
            gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
            gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
            gl.TexImage2D(gl.TEXTURE_2D, 0, snesW, snesH, gl.RGBA, gl.UNSIGNED_BYTE, nil)

            buf = gl.CreateBuffer()
            gl.BindBuffer(gl.ARRAY_BUFFER, buf)
            gl.BufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW)
          }

          func onStop() {
            gl.DeleteProgram(program)
            gl.DeleteBuffer(buf)
            gl.DeleteTexture(texture)
          }

          func onPaint(a app.App) {
            mu.Lock()
            if console != nil {
               console.RunFrame()
               console.SetPixels(pixels)
               gl.BindTexture(gl.TEXTURE_2D, texture)
               gl.TexImage2D(gl.TEXTURE_2D, 0, snesW, snesH, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
            }
            mu.Unlock()

            gl.ClearColor(0, 0, 0, 1)
            gl.Clear(gl.COLOR_BUFFER_BIT)

            gl.UseProgram(program)
            gl.BindBuffer(gl.ARRAY_BUFFER, buf)

            gl.EnableVertexAttribArray(position)
            gl.VertexAttribPointer(position, 2, gl.FLOAT, false, 16, 0)

            gl.EnableVertexAttribArray(texCoord)
            gl.VertexAttribPointer(texCoord, 2, gl.FLOAT, false, 16, 8)

            gl.DrawArrays(gl.TRIANGLE_STRIP, 0, 4)

            a.Publish()
            a.Send(paint.Event{}) 
          }

          func onTouch(t touch.Event) {
            mu.Lock()
            defer mu.Unlock()
            if console == nil { return }

            pressed := t.Type == touch.TypeBegin || t.Type == touch.TypeMove
            x := float32(t.X)
            y := float32(t.Y)
            w := float32(screenW)
            h := float32(screenH)

            if x < w/2 {
                cy := h / 2
                cx := w / 4
                console.SetButtonState(1, 4, pressed && y < cy - 50) 
                console.SetButtonState(1, 5, pressed && y > cy + 50) 
                console.SetButtonState(1, 6, pressed && x < cx - 50) 
                console.SetButtonState(1, 7, pressed && x > cx + 50) 
                console.SetButtonState(1, 2, pressed && y > h - 150 && x < 150)
                console.SetButtonState(1, 3, pressed && y > h - 150 && x > 150 && x < 300)
            } else {
                cy := h / 2
                cx := w * 0.75
                console.SetButtonState(1, 8, pressed && x > cx + 50)
                console.SetButtonState(1, 0, pressed && y > cy + 50) 
                console.SetButtonState(1, 9, pressed && y < cy - 50) 
                console.SetButtonState(1, 1, pressed && x < cx - 50) 
            }
          }

          var vertexShader = `
          #version 100
          attribute vec2 position;
          attribute vec2 texCoord;
          varying vec2 v_texCoord;
          void main() {
            gl_Position = vec4(position, 0.0, 1.0);
            v_texCoord = texCoord;
          }` + "\x00"

          var fragmentShader = `
          #version 100
          precision mediump float;
          varying vec2 v_texCoord;
          uniform sampler2D texture;
          void main() {
            gl_FragColor = texture2D(texture, v_texCoord);
          }` + "\x00"

          var vertexData = f32Bytes(
            -1, -1,  0, 1,
             1, -1,  1, 1,
            -1,  1,  0, 0,
             1,  1,  1, 0,
          )

          func f32Bytes(values ...float32) []byte {
            b := make([]byte, 4*len(values))
            for i, v := range values {
              binary.LittleEndian.PutUint32(b[i*4:], math.Float32bits(v))
            }
            return b
          }
          EOF

      # 4. CRIAR DUMMY ROM (FALLBACK)
      - name: Create Dummy ROM
        run: dd if=/dev/zero of=cmd/mobile/assets/game.sfc bs=1024 count=1024

      # ---------------------------------------------------------
      # 4. AMBIENTE (COM CORREÇÃO DE NDK)
      # ---------------------------------------------------------
      - name: Setup JDK 17
        uses: actions/setup-java@v4
        with: { java-version: '17', distribution: 'temurin' }

      - name: Setup Go
        uses: actions/setup-go@v4
        with: { go-version: 'stable' }

      # CORREÇÃO: Instala NDK r25b (Estável para Gomobile)
      - name: Setup Android NDK
        uses: nttld/setup-ndk@v1
        with:
          ndk-version: r25b
          add-to-path: true

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      # ---------------------------------------------------------
      # 5. BUILD DO APK PURO (COM CGO E NDK FIX)
      # ---------------------------------------------------------
      - name: Build Pure Go APK
        env:
          # Define explicitamente onde o NDK está (a action setup-ndk define essa env var)
          ANDROID_NDK_HOME: ${{ steps.setup-ndk.outputs.ndk-path }}
        run: |
          go install golang.org/x/mobile/cmd/gomobile@latest
          gomobile init
          
          # Baixa dependências
          go get golang.org/x/mobile/gl
          go get golang.org/x/mobile/app
          go get golang.org/x/mobile/event/touch
          go get golang.org/x/image/font/gofont/goregular
          go mod tidy

          echo "Usando NDK em: $ANDROID_NDK_HOME"

          # Compila com CGO ativado e flags de API corretas
          CGO_ENABLED=1 gomobile build -target=android -androidapi 21 -o chibisnes.apk ./cmd/mobile

      - name: Commit Changes
        run: |
          git config --global user.name "AutoPort"
          git config --global user.email "autoport@bot"
          git add .
          git commit -m "Pure Go with Storage Access" || echo "Nada novo"
          git push

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: chibisnes-pure-go
          path: chibisnes.apk
