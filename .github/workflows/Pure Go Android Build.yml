name: Pure Go Android Build

on:
  workflow_dispatch:
  push:
    branches: [ "main", "master" ]

permissions:
  contents: write

jobs:
  build-native:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ---------------------------------------------------------
      # 1. LIMPEZA TOTAL (Removemos o projeto Android Studio)
      # ---------------------------------------------------------
      - name: Clean Previous Android Project
        run: |
          rm -rf android mobile cmd internal .github/workflows/release.yml || true
          mkdir -p cmd/mobile
          mkdir -p assets

      # ---------------------------------------------------------
      # 2. CÓDIGO GO NATIVO (OPENGL + TOUCH)
      # ---------------------------------------------------------
      - name: Create Native Go Engine
        run: |
          cat << 'EOF' > cmd/mobile/main.go
          package main

          import (
            "encoding/binary"
            "log"
            "time"
            "image"
            "sync"

            "golang.org/x/mobile/app"
            "golang.org/x/mobile/event/lifecycle"
            "golang.org/x/mobile/event/paint"
            "golang.org/x/mobile/event/size"
            "golang.org/x/mobile/event/touch"
            "golang.org/x/mobile/gl"
            "golang.org/x/mobile/asset"

            "github.com/kaishuu0123/chibisnes/chibisnes"
          )

          var (
            console   *chibisnes.Console
            program   gl.Program
            position  gl.Attrib
            texCoord  gl.Attrib
            texture   gl.Texture
            buf       gl.Buffer
            screenW   int
            screenH   int
            mu        sync.Mutex
            pixels    []byte
          )

          const (
            snesW = 512
            snesH = 478 // Altura segura para interlace
          )

          func main() {
            app.Main(func(a app.App) {
              for e := range a.Events() {
                switch e := a.Filter(e).(type) {
                case lifecycle.Event:
                  if e.Crosses(lifecycle.StageVisible) == lifecycle.CrossOn {
                    startEmulator()
                    onStart()
                  }
                  if e.Crosses(lifecycle.StageVisible) == lifecycle.CrossOff {
                    onStop()
                  }
                case size.Event:
                  screenW = e.WidthPx
                  screenH = e.HeightPx
                case paint.Event:
                  onPaint(a)
                case touch.Event:
                  onTouch(e)
                }
              }
            })
          }

          func startEmulator() {
            mu.Lock()
            defer mu.Unlock()
            
            if console != nil { return }

            // Tenta carregar ROM dos assets (embutido no APK)
            f, err := asset.Open("game.sfc")
            if err != nil {
               log.Println("Erro ao abrir ROM:", err)
               // Cria console vazio só para não crashar
               console = chibisnes.NewConsole()
               return
            }
            defer f.Close()

            // Lê tamanho
            info, _ := f.Stat()
            size := info.Size()
            data := make([]byte, size)
            f.Read(data)

            console = chibisnes.NewConsole()
            console.LoadROM("game.sfc", data, int(size))
            
            // Prepara buffer de pixels
            pixels = make([]byte, snesW*snesH*4)
          }

          func onStart() {
            var err error
            program, err = gl.CreateProgram()
            if err != nil { return }

            vs, _ := gl.CreateShader(gl.VERTEX_SHADER)
            gl.ShaderSource(vs, vertexShader)
            gl.CompileShader(vs)
            gl.AttachShader(program, vs)

            fs, _ := gl.CreateShader(gl.FRAGMENT_SHADER)
            gl.ShaderSource(fs, fragmentShader)
            gl.CompileShader(fs)
            gl.AttachShader(program, fs)

            gl.LinkProgram(program)
            gl.UseProgram(program)

            position = gl.GetAttribLocation(program, "position")
            texCoord = gl.GetAttribLocation(program, "texCoord")
            
            gl.Uniform1i(gl.GetUniformLocation(program, "texture"), 0)

            texture = gl.CreateTexture()
            gl.BindTexture(gl.TEXTURE_2D, texture)
            gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
            gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
            
            // Aloca textura vazia
            gl.TexImage2D(gl.TEXTURE_2D, 0, snesW, snesH, gl.RGBA, gl.UNSIGNED_BYTE, nil)

            // Quad vertices (Full Screen)
            buf = gl.CreateBuffer()
            gl.BindBuffer(gl.ARRAY_BUFFER, buf)
            gl.BufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW)
          }

          func onStop() {
            gl.DeleteProgram(program)
            gl.DeleteBuffer(buf)
            gl.DeleteTexture(texture)
          }

          func onPaint(a app.App) {
            mu.Lock()
            if console != nil {
               console.RunFrame()
               console.SetPixels(pixels)
               
               // Upload textura
               gl.BindTexture(gl.TEXTURE_2D, texture)
               // Hack: TexSubImage é mais rapido, mas TexImage é mais simples para evitar erros de formato agora
               gl.TexImage2D(gl.TEXTURE_2D, 0, snesW, snesH, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
            }
            mu.Unlock()

            gl.ClearColor(0, 0, 0, 1)
            gl.Clear(gl.COLOR_BUFFER_BIT)

            gl.UseProgram(program)
            gl.BindBuffer(gl.ARRAY_BUFFER, buf)

            gl.EnableVertexAttribArray(position)
            gl.VertexAttribPointer(position, 2, gl.FLOAT, false, 16, 0)

            gl.EnableVertexAttribArray(texCoord)
            gl.VertexAttribPointer(texCoord, 2, gl.FLOAT, false, 16, 8)

            gl.DrawArrays(gl.TRIANGLE_STRIP, 0, 4)

            a.Publish()
            
            // Força repaint continuo (Game Loop)
            a.Send(paint.Event{})
          }

          // CONTROLES DE TOQUE (Touchscreen)
          // Divide a tela em areas para simular controle
          func onTouch(t touch.Event) {
            mu.Lock()
            defer mu.Unlock()
            if console == nil { return }

            pressed := t.Type == touch.TypeBegin || t.Type == touch.TypeMove
            x := t.X
            y := t.Y
            w := float32(screenW)
            h := float32(screenH)

            // Lado Esquerdo: D-PAD
            // Lado Direito: Botões
            
            // IDs do ChibiSNES:
            // B=0, Y=1, Select=2, Start=3, Up=4, Down=5, Left=6, Right=7, A=8, X=9, L=10, R=11

            if x < w/2 {
                // D-PAD Logic (Quadrantes simples na esquerda)
                centerY := h / 2
                centerX := w / 4
                
                // Zona morta simples
                console.SetButtonState(1, 4, pressed && y < centerY - 50) // UP
                console.SetButtonState(1, 5, pressed && y > centerY + 50) // DOWN
                console.SetButtonState(1, 6, pressed && x < centerX - 50) // LEFT
                console.SetButtonState(1, 7, pressed && x > centerX + 50) // RIGHT
                
                // Select/Start no canto inferior esquerdo
                console.SetButtonState(1, 2, pressed && y > h - 100 && x < 100) // Select
                console.SetButtonState(1, 3, pressed && y > h - 100 && x > 100 && x < 200) // Start

            } else {
                // Buttons Logic (Direita)
                // A(dir), B(baixo), X(cima), Y(esq)
                centerY := h / 2
                centerX := w * 0.75
                
                console.SetButtonState(1, 8, pressed && x > centerX + 50) // A
                console.SetButtonState(1, 0, pressed && y > centerY + 50) // B
                console.SetButtonState(1, 9, pressed && y < centerY - 50) // X
                console.SetButtonState(1, 1, pressed && x < centerX - 50) // Y
            }
          }

          var vertexShader = `#version 100
          attribute vec2 position;
          attribute vec2 texCoord;
          varying vec2 v_texCoord;
          void main() {
            gl_Position = vec4(position, 0.0, 1.0);
            v_texCoord = texCoord;
          }`

          var fragmentShader = `#version 100
          precision mediump float;
          varying vec2 v_texCoord;
          uniform sampler2D texture;
          void main() {
            gl_FragColor = texture2D(texture, v_texCoord);
          }`

          var vertexData = f32Bytes(
            -1, -1,  0, 1, // Bottom Left
             1, -1,  1, 1, // Bottom Right
            -1,  1,  0, 0, // Top Left
             1,  1,  1, 0, // Top Right
          )

          func f32Bytes(values ...float32) []byte {
            b := make([]byte, 4*len(values))
            for i, v := range values {
              u := 0 // math.Float32bits(v) -> hack simples abaixo
              // Gomobile nao tem math simples as vezes, convertendo na mao
              // Ops, math esta na stdlib.
              // Simplificando: vamos assumir Endianness do host pois é OpenGL data
              binary.LittleEndian.PutUint32(b[i*4:], uint32(*(*uint32)(unsafePointer(&v))))
            }
            return b
          }
          
          import "unsafe"
          func unsafePointer(f *float32) *uint32 {
             return (*uint32)(unsafe.Pointer(f))
          }
          EOF

      # ---------------------------------------------------------
      # 3. CRIAÇÃO DE ROM FALSA (Para o build não falhar)
      # ---------------------------------------------------------
      - name: Create Dummy ROM
        run: |
          # Cria um arquivo binário qualquer para ser "embedado" no APK
          # Você pode substituir isso por um comando 'curl' para baixar uma ROM de homebrew
          dd if=/dev/zero of=assets/game.sfc bs=1024 count=1024

      # ---------------------------------------------------------
      # 4. CONFIGURAÇÃO DO AMBIENTE
      # ---------------------------------------------------------
      - name: Setup JDK 17
        uses: actions/setup-java@v4
        with: { java-version: '17', distribution: 'temurin' }

      - name: Setup Go
        uses: actions/setup-go@v4
        with: { go-version: 'stable' }

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      # ---------------------------------------------------------
      # 5. BUILD DO APK PURO (GOMOBILE BUILD)
      # ---------------------------------------------------------
      - name: Build APK (Pure Go)
        run: |
          go install golang.org/x/mobile/cmd/gomobile@latest
          gomobile init
          
          # Baixa dependências gráficas
          go get golang.org/x/mobile/gl
          go get golang.org/x/mobile/app
          go get golang.org/x/mobile/event/touch
          
          # Compila direto para APK incluindo a pasta assets
          # -target=android gera o APK. 
          # -assets assets/ inclui o game.sfc
          gomobile build -target=android -androidapi 21 -assets assets -o chibisnes.apk ./cmd/mobile

      # ---------------------------------------------------------
      # 6. UPLOAD E COMMIT
      # ---------------------------------------------------------
      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: chibisnes-pure-go
          path: chibisnes.apk

      - name: Commit Changes
        run: |
          git config --global user.name "AutoPort"
          git config --global user.email "autoport@bot"
          git add .
          git commit -m "Convert to Pure Go Gomobile App" || echo "Nada novo"
          git push
